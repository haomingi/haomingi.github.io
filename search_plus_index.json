{"./":{"url":"./","title":"自述","keywords":"","body":"自述 岁寒，然后知松柏之后凋也。 一个前端开发者，记录前端开发的一些笔记，共勉。 内容主题 静态基础 javaScript基础 ES6 vue react 2019面试笔记整理 js学习资料 javaScript高级编程第三版 你不知道的javaScript上、中、下 Gitbook学习资料 Gitbook简易教程 GitBook插件整理 部分资料来源于互联网，如有侵权，请联系：haomingi@sina.com Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 20:28:42 "},"docs/info.html":{"url":"docs/info.html","title":"介绍","keywords":"","body":"介绍 开始 主要记录在前端开发的过程中，学习积累的一些知识。从一个前端小白，到现在从事前端开发已有五年时间，我也不知道自己学习了多少知识，趁此机会查漏补缺。 本篇记录的内容都是一些我认为好的，平常工作中用到但是对具体的概念、细节不是很清晰的内容，希望阅读者具备一定的前端开发基础。 Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/front/":{"url":"docs/front/","title":"静态基础","keywords":"","body":"本章说 在前端开发中，Html、css是必不可少的两块内容，其中一些内容平时有用到，但是对其概念内容却理解的不是很深入! Html BFC(块级格式化上下文) 重绘、回流 css 多行文本溢出 水平垂直居中 防抖 硬件加速 Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/front/html.html":{"url":"docs/front/html.html","title":"Html","keywords":"","body":"Html Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/front/css.html":{"url":"docs/front/css.html","title":"css","keywords":"","body":"css Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/js/":{"url":"docs/js/","title":"javaScript基础","keywords":"","body":"本章说 学习js部分导言，介绍学习js必懂的入门知识！个人认为从入门到熟练，会打断点跟代码是必备掌握的技能！ 隐式强制类型转换 this Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/js/base.html":{"url":"docs/js/base.html","title":"基础内容","keywords":"","body":"js Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/es6/":{"url":"docs/es6/","title":"ES6","keywords":"","body":"本章说 Es6中提供的新的Api，对以往开发过程中遇到的一些问题给出了官方解决方案，提高了效率，但针对于使用，我们也要变通的、转换方式的去了解其实现! 箭头函数 Promise Set Map 生成器 迭代器 Symbol Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/es6/base.html":{"url":"docs/es6/base.html","title":"箭头函数","keywords":"","body":"箭头函数 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。 基础用法 var elements = [ 'Hydrogen', 'Helium', 'Lithium', 'Beryllium' ]; elements.map(function(element) { return element.length; }); // 返回数组：[8, 6, 7, 9] // 上面的普通函数可以改写成如下的箭头函数 elements.map((element) => { return element.length; }); // [8, 6, 7, 9] // 当箭头函数只有一个参数时，可以省略参数的圆括号 elements.map(element => { return element.length; }); // [8, 6, 7, 9] // 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号 elements.map(element => element.length); // [8, 6, 7, 9] 不绑定this 在箭头函数出现之前，每个新定义的函数都有它自己的 this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被作为'对象方法'调用则为基础对象等）。 function Person() { // Person() 构造函数定义 `this`作为它自己的实例. this.age = 0; setInterval(function growUp() { // 在非严格模式, growUp()函数定义 `this`作为全局对象, // 与在 Person()构造函数中定义的 `this`并不相同. this.age++; }, 1000); } var p = new Person(); 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同： function Person(){ this.age = 0; setInterval(() => { this.age++; // |this| 正确地指向 p 实例 }, 1000); } var p = new Person(); 通过 call 或 apply 调用 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。 箭头函数被声明的时候，就会从自己的作用域链的上一层继承this，call() 或 apply()调用箭头函数，跟普通函数效果不同，this不会发生改变！ var a = { o: 1 } var b = { o: 2 } // 声明函数objFun function objFun () { return () => { console.log(this) } } // 此时箭头函数被声明，this确定 var c = objFun.call(a) // 结果{o: 1} c() // 更改不会生效,结果{o: 1} c.call(b) 不绑定this 箭头函数不绑定Arguments对象。因此，在本示例中，arr使用的是创建的arguments数组，foo中f函数中的arguments只是引用了封闭作用域内的arguments。 var arguments = [1, 2, 3]; // 此处的arguments就是上面的数组，不是函数内的参数 var arr = () => arguments[0]; var a = arr(); // 1 console.log(a); function foo (n, s) { // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n // arguments[1]=4 n=1 ; 4 + 1 = 5 var f = () => arguments[1] + n; return f(); } var f = foo(1, 4); // 5 console.log(f); 像函数一样使用箭头函数 箭头函数继承父作用域this 'use strict'; var obj = { i: 10, b: () => console.log(this.i, this), c: function() { console.log( this.i, this) } } obj.b(); // undefined, Window{...} obj.c(); // 10, Object {...} Object.defineProperty()的示例 'use strict'; var obj = { a: 10 }; Object.defineProperty(obj, \"b\", { get: () => { console.log(this.a, typeof this.a, this); return this.a+10; // 代表全局对象 'Window', 因此 'this.a' 返回 'undefined' } }); // undefined \"undefined\" Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …} obj.b; prototype示例 foo = 1111 function A() { this.foo = 1 } A.prototype.bar = () => console.log(this.foo) let a = new A() // 打印结果1111。此处箭头函数指向仍然是Window a.bar() 使用 new 操作符 箭头函数不能用作构造器，和 new一起用会抛出错误。 var Foo = () => {}; // TypeError: Foo is not a constructor var foo = new Foo(); 使用prototype属性 箭头函数没有prototype属性。 var Foo = () => {}; // undefined console.log(Foo.prototype); 使用 yield 关键字 yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。 Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/vue/":{"url":"docs/vue/","title":"vue","keywords":"","body":"本章说 学习vue部分导言，介绍学习vue必懂的入门知识！ 数据双向绑定之前 双向绑定 watch对象初始化 计算属性初始化 Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/vue/base.html":{"url":"docs/vue/base.html","title":"数据双向绑定之前","keywords":"","body":"双向绑定之前 在_init方法最后，会调用vm.$mount(vm.$options.el)，进行挂载，此时调用的是： const mount = Vue.prototype.$mount // runtime/index.js Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component {} 此时有一个mount备份,然后重新定义了$mount,$mount方法主要做的就是判断当前是否定义了render函数，没有定义的话拿template转化一个render函数，挂载到vm实例上面。然后调用mount备份函数 return mount.call(this, el, hydrating) mount函数源码： Vue.prototype.$mount = function ( el?: any, hydrating?: boolean ): Component { return mountComponent( this, el && query(el, this.$document), hydrating ) } mountComponent函数就是主要的函数挂载逻辑了（lifecycle.js）,核心代码以下两个： updateComponent = () => { // vm._render()生成虚拟dom 然后更新 vm._update(vm._render(), hydrating) } new Watcher(vm, updateComponent, noop, { before () { // 意思就是之前运行，触发钩子 if (vm._isMounted && !vm._isDestroyed) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) new Watcher 创建时候传入的第二个参数就是当前watcher被通知时候要调用的函数 创建Watcher实例，传入vm、updateComponent，构造函数运行时候，把updateComponent赋值给了watch实例的getter上，当调用this.get()时候，先把当前watch赋值给Dep.target上，在直接调用了this.getter.call(vm,vm)=>updateComponent，传入的第五个参数确定了当前watcher为renderWatcher。 updateComponent先调用了vm._render()生成虚拟dom，这个时候就是一次全局取数，renderWatcher与依赖的数据建立了依赖，vm._update()会根据虚拟dom，更新视图。 当renderWatcher被依赖的数据通知发生改变的时候，默认调用renderWatcher上的update方法 update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true } else if (this.sync) { this.run() } else { queueWatcher(this) } } queueWatcher对当前renderWatcher判断，防止多次调用，之后调用.run()方法，又一次调用了this.get()，此时在一次走上方加粗内容的逻辑，形成一个创建、更新的闭环。 Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/vue/observe.html":{"url":"docs/vue/observe.html","title":"双向绑定","keywords":"","body":"双向绑定 在_init()调用的时候有一个initState()此时对组件内部定义的内容进行初始化 export function initState (vm: Component) { vm._watchers = [] const opts = vm.$options // 初始化的顺序 // 1 if (opts.props) initProps(vm, opts.props) // 2 if (opts.methods) initMethods(vm, opts.methods) // 3 if (opts.data) { initData(vm) } else { observe(vm._data = {}, true /* asRootData */) } // 4 if (opts.computed) initComputed(vm, opts.computed) // 5 if (opts.watch && opts.watch !== nativeWatch) { initWatch(vm, opts.watch) } } 顺序按照上方的1-5，现在主要看initData() function initData (vm: Component) { let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== 'production' && warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) } // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length // 判断props中的变量是否与data重复 while (i--) { const key = keys[i] if (process.env.NODE_ENV !== 'production') { if (methods && hasOwn(methods, key)) { warn( `Method \"${key}\" has already been defined as a data property.`, vm ) } } if (props && hasOwn(props, key)) { process.env.NODE_ENV !== 'production' && warn( `The data property \"${key}\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) } else if (!isReserved(key)) { proxy(vm, `_data`, key) } } // observe data observe(data, true /* asRootData */) } initData中先获取当时组件上面定义的data，这个时候进行一个data类型的判断，data默认应该是一个函数返回一个对象，这样处理是为了在该组件多次调用时候，数据不会互相影响。 之后while循环判断props中的变量是否与data重复，一切正常调用observe函数 export function observe (value: any, asRootData: ?boolean): Observer | void { if (!isObject(value) || value instanceof VNode) { return } let ob: Observer | void // 挂载了就直接取 if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue ) { ob = new Observer(value) } if (asRootData && ob) { ob.vmCount++ } return ob } 先判断observe是否创建（ob有没有），创建了就直接取，没有的话new一个 export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) { if (hasProto) { protoAugment(value, arrayMethods) } else { copyAugment(value, arrayMethods, arrayKeys) } this.observeArray(value) } else { this.walk(value) } } /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i ) { for (let i = 0, l = items.length; i Observer函数先存储自身，def(value, 'ob', this)，之后针对于data进行判断。 是数组的话循环给每一项调用observe，此处会针对于数组修改默认的数组方法，使vue能够监听数组数据改变。 是对象，循环给每个字段调用defineReactive(obj, keys[i])，defineReactive主要逻辑： const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val // 组件里面取值时候没有watcher if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal && value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' && customSetter) { customSetter() } // #7981: for accessor properties without setter // 计算属性 if (getter && !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow && observe(newVal) dep.notify() } }) 对每个传入的字段，都创建一个dep，看当前字段是否可修改，都添加set、get方法 get方法 get方法调用分为两次情况，一种是Watcher建立依赖时候，一种是组件内容取值调用，是通过Dep.target判断，此字段觉得了是否走后面的依赖建立逻辑。 get: function reactiveGetter () { const value = getter ? getter.call(obj) : val // 组件里面取值时候没有watcher if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value } dep.depend()会调用Dep.target中存储的watcher，watcher判断下与当前dep是否建立过一次（模板中多次用一个字段），就是看当前dep的id在watcher里面存没存过，如果没有建立依赖，watcher存储dep，调用dep.addSub(this),使dep存储watcher，此时双方依赖建立完成。 set方法 set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal && value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' && customSetter) { customSetter() } // #7981: for accessor properties without setter // 计算属性 if (getter && !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow && observe(newVal) dep.notify() } 先判断新旧值是否一直，判断当前字段是否有setter方法，没有就返回。 更新数据，dep循环通知存储的watcher，watcher进行queue处理。 export function queueWatcher (watcher: Watcher) { const id = watcher.id if (has[id] == null) { has[id] = true if (!flushing) { queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i > index && queue[i].id > watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true if (process.env.NODE_ENV !== 'production' && !config.async) { flushSchedulerQueue() return } nextTick(flushSchedulerQueue) } } } queue会判断当前watcher是否已经被queue存下(就是存下watch.id),没有处理就把watcher加入到queue数组中，此处有waiting判断，只会调用nextTick一次，之后调用queueWatcher就是存储到queue数组中去(事件循环中修改多个字段时候每个字段都会通知一次)。 flushSchedulerQueue运行时候会循环调用queue数组中的每一个watcher.run()运行，重新触发this.get()，触发创建watch时候传入的第二个参数this.getter.call(vm,vm)。example:renderWatcher运行的是updateComponent。 nextTick nextTick函数重点是在浏览器运行时候区分环境，此处判断是使用微任务还是宏任务。 if (typeof Promise !== 'undefined' && isNative(Promise)) { const p = Promise.resolve() timerFunc = () => { p.then(flushCallbacks) if (isIOS) setTimeout(noop) } isUsingMicroTask = true } else if (!isIE && typeof MutationObserver !== 'undefined' && ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]' )) { // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () => { counter = (counter + 1) % 2 textNode.data = String(counter) } isUsingMicroTask = true } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) { // Fallback to setImmediate. // Techinically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = () => { setImmediate(flushCallbacks) } } else { // Fallback to setTimeout. timerFunc = () => { setTimeout(flushCallbacks, 0) } } 看是否支持promise/MutationObserver/setImmediate/setTimeout，此处需要知道微任务运行的比宏任务早，判断目的就是为了尽快运行。 Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/vue/initwatch.html":{"url":"docs/vue/initwatch.html","title":"watch对象初始化","keywords":"","body":"watch对象初始化 function initWatch (vm: Component, watch: Object) { for (const key in watch) { const handler = watch[key] if (Array.isArray(handler)) { for (let i = 0; i initWatch中拿到组件定的watch对象，循环拿到key/handler（key=>要监听的字段名,handler是字段改变回调）。 createWatcher函数根据传入的key/handler创建watcher实例 Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object ): Function { const vm: Component = this if (isPlainObject(cb)) { return createWatcher(vm, expOrFn, cb, options) } options = options || {} options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) 判断此监听事件是否立即执行 if (options.immediate) { try { cb.call(vm, watcher.value) } catch (error) { handleError(error, vm, `callback for immediate watcher \"${watcher.expression}\"`) } } return function unwatchFn () { watcher.teardown() } } const watcher = new Watcher(vm, expOrFn, cb, options) 传入vm key handler，watcher构造函数运行时候会调用this.get(),把当前watch实例赋值给Dep.target,调用this.getter.call(vm,vm)也就是直接调用vm.key，完成一次对监听字段的取数，调用了key的get方法，使key对应的dep与当前watch完成绑定。 this.$watch 在created/mounted中动态创建watch时候，因为创建的时间在renderWatch之后，所以watch.id大于renderWatch，定义的watch与renderWatch同时触发的时候，renderWatch会先走。 修改watch if (options) { this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync this.before = options.before debugger this.dynamic = options.dynamic } else { this.deep = this.user = this.lazy = this.sync = false } this.cb = cb this.id = this.dynamic ? --dynamicUid : ++uid // uid for batching this.$watch('a', function (newVal, oldVal) { // 做点什么 console.log('watch2') }, { dynamic: true }) 默认情况动态watch是在renderWatch之后走。此处添加一个dynamic字段，设置watch.id小于0，但是此多个watch顺序无法控制。 flushSchedulerQueue中针对quque数组排序的时候，把vm._watcher上的renderWatch放到数组最后面，最后调用。在默认queue.sort之后添加下面四行。 queue.sort((a, b) => a.id - b.id) // 处理动态watch与renderWatch顺序 let renderWatch = queue[0].vm._watcher || { id: 0 } let renderWatchIndex = queue.findIndex((item) => item.id === renderWatch.id) queue.splice(renderWatchIndex, 1) queue.push(renderWatch) 可以给一个字段设置多个watch Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 20:29:42 "},"docs/vue/initcomputed.html":{"url":"docs/vue/initcomputed.html","title":"计算属性初始化","keywords":"","body":"计算属性初始化 const computedWatcherOptions = { lazy: true } function initComputed (vm: Component, computed: Object) { // $flow-disable-line const watchers = vm._computedWatchers = Object.create(null) // computed properties are just getters during SSR const isSSR = isServerRendering() for (const key in computed) { const userDef = computed[key] const getter = typeof userDef === 'function' ? userDef : userDef.get if (process.env.NODE_ENV !== 'production' && getter == null) { warn( `Getter is missing for computed property \"${key}\".`, vm ) } if (!isSSR) { // create internal watcher for the computed property. // 其实就是添加一个watcher，每添加一个，this.watchers中就多一个，可以试试。 // computedWatcherOptions 定义懒惰watcher watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ) } // component-defined computed properties are already defined on the // component prototype. We only need to define computed properties defined // at instantiation here. if (!(key in vm)) { defineComputed(vm, key, userDef) } else if (process.env.NODE_ENV !== 'production') { if (key in vm.$data) { warn(`The computed property \"${key}\" is already defined in data.`, vm) } else if (vm.$options.props && key in vm.$options.props) { warn(`The computed property \"${key}\" is already defined as a prop.`, vm) } } } } 包装回调函数 此处使用computedWatcherOptions定义了一个lazy字段，此字段用在创建watch时候，进行代码状态的区分！ 判断_computedWatchers函数是否存在，不存在了创建，存入vm中。 循环computed，拿到key/userDef。 判断是否服务端渲染。 根据key/userDef/computedWatcherOptions，创建watcher实例，存入vm._computedWatchers对象中。 判断计算属性key是否与props/data命名冲突，目的是此处会在vm上创建一个以计算属性名称一致的字段，用以保存计算属性计算值（快照）。第一次计算属性计算完成之后，不发生改变的情况下，之后的renderWatcher渲染时候都从此处取值，不会从新调用计算属性函数计算结果（watch.value）。 此处watcher创建有不同之处！ 默认情况下watch构造函数运行的时候回默认调用this.get()去进行依赖收集，此处传递的computedWatcherOptions.lazy会阻止这一行为，同时维护一个dirty去控制watch调用get函数。 目的是有些时候定义了一个计算属性，但是在当前模板中没有使用，此处直接去绑定就会是无效操作。 vm上创建字段 export function defineComputed ( target: any, key: string, userDef: Object | Function ) { const shouldCache = !isServerRendering() if (typeof userDef === 'function') { sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef) sharedPropertyDefinition.set = noop } else { 直接传递进来get set方法的情况 sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop sharedPropertyDefinition.set = userDef.set || noop } if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) { sharedPropertyDefinition.set = function () { warn( `Computed property \"${key}\" was assigned to but it has no setter.`, this ) } } // 在vm上创建一个computed名字一样的字段 添加get方法 Object.defineProperty(target, key, sharedPropertyDefinition) } function createComputedGetter (key) { return function computedGetter () { // 取到watcher const watcher = this._computedWatchers && this._computedWatchers[key] if (watcher) { // dirty为true的时候，进行一次取数，双方绑定依赖 if (watcher.dirty) { watcher.evaluate() } // dep watcher关系以及绑定 // 看此时还有顶层watcher没有，有了接着绑定。这个是针对绑定组件watcher，当计算属性依赖的字段改变时，出了依赖组件被通知，外侧watcher也被通知了！！！ if (Dep.target) { // 与deps绑定依赖 watcher.depend() } return watcher.value } } } 此处是在vm上创建一个跟计算属性名称一样的字段（key）,同时只给此字段添加一个get方法（computedGetter），如果定义的时候自己配置的有set/get就用自己定的。 此处代码完成，此时仍没有进行依赖绑定。 createComputedGetter 此函数调用的返回函数computedGetter就是vm.key的get函数，当renderWatcher进行依赖绑定的时候，获取计算属性值，此函数会运行。 取到vm._computedWatchers上存储的watcher 判断watcher.dirty，这个字段就是判断watcher是否需要计算值 watcher.evaluate()运行调用this.get()，设置Dep.target，运行计算属性的函数，此次函数运行会对内部依赖的字段进行取值，双方建立依赖关系。获取函数运行结果，赋值给vm.key this.dirty = false，关闭watch运行状态。模板中多次用一个计算属性时候，只有第一次计算属性函数会运行，之后就不会运行。 watcher.get()方法，会先设置设置Dep.target = 当前watcher，双方依赖绑定之后会调用popTarget()，把当前watcher移除Dep.target export function popTarget () { // 删除最后一个watcher targetStack.pop() // 看前面是不是还有watcher Dep.target = targetStack[targetStack.length - 1] } 此时需要注意！ 当前computedGetter运行是因为renderWatcher在进行取数，所以在computedGetter运行前，Dep.target=renderWatcher，renderWatcher备份存储在targetStack中，computedGetter运行后，使用计算属性watch替换了Dep.target，targetStack中就存储了两个watcher[renderWatcher, 计算属性watch] popTarget函数调用，移除了计算属性watch，同时把renderWatcher赋值给Dep.target computedGetter函数中的这段代码 if (Dep.target) { // 与deps绑定依赖 watcher.depend() } 此处Dep.target等于renderWatcher，取到计算属性watcher依赖的deps，与当前Dep.targt（renderWatcher），建立依赖关系！！！ 因此！此处进行了两次watcher依赖绑定。 计算属性使用的字段与计算属性watch绑定 计算属性使用的字段与renderWatcher 当字段发生改变时候，根据存储的watcher先后顺序，先通知计算属性watch，在通知renderWatcher。 update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true } else if (this.sync) { this.run() } else { queueWatcher(this) } } 字段deps通知watch，会判断this.lazy，把当前计算属性watch的dirty更改，使其重新计算结果。 注意！ 此处通过lazy区分了不同的逻辑，计算属性的wathcer不会被放入到queue队列中去。 example 当template中先使用了a变量，之后使用的计算属性钟也使用了a变量，根据先后顺序，是a变量先跟renderWatcher建立依赖，然后renderWatcher取数到计算属性的时候，a与计算属性建立依赖。 理论上，那么当a发生数据改变的时候，也是根据先后顺序触发renderWatcher、计算属性watcher（看上方注意的那句话）。 export function queueWatcher (watcher: Watcher) { const id = watcher.id if (has[id] == null) { has[id] = true if (!flushing) { queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i > index && queue[i].id > watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true if (process.env.NODE_ENV !== 'production' && !config.async) { flushSchedulerQueue() return } nextTick(flushSchedulerQueue) } } } flushing默认是false，只有当flushSchedulerQueue开始运行的时候改为true，在这个时候如果某个更新触发了数据更改，queueWatcher重新走了，就直接插入到queue中，看下方代码。 此处： while (i > index && queue[i].id > watcher.id) { i-- } 会判断当前已存储queue[i].id与当次存入watcher.id的大小，找到存储watch的位置，id小的放到前面去先调用。 watch、renderWatcher、计算属性，以上三个都触发的时候，运行顺序。 计算属性watch最先创建、watch、renderWatcher 计算属性watch创建之后没有与数据绑定，最先绑定的是watch 某个字段在三个watcher中都使用的时候，如果根据例子的顺序，字段deps[watch, renderWatcher, 计算属性watch] flushSchedulerQueue函数会对维护的queue排序，queue.sort((a, b) => a.id - b.id) 排序之后计算属性在前，之后是watch，最后是renderWatcher 看watch.update函数 update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true } else if (this.sync) { this.run() } else { queueWatcher(this) } } 当实际的watch被循环调用的时候，计算属性的watch没有被放入到queue中去，只是更改了dirty字段，所以实际运行的是(watch,renderWatch)两个watch，当renderWatch运行的时候，会调用计算属性，计算属性的dirty为true，从新计算！ Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 20:29:27 "},"docs/react/":{"url":"docs/react/","title":"react","keywords":"","body":"本章说 学习react部分导言，介绍学习react必懂的入门知识！ 发送ajax update hooks 高阶函数 Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/react/base.html":{"url":"docs/react/base.html","title":"基础内容","keywords":"","body":"js Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/offer/":{"url":"docs/offer/","title":"2019面试笔记整理","keywords":"","body":"本章说 2019-02月面试题库！ 数组拉平（递归） 柯里化 js动画与css动画对比 冒泡排序 数组去重 13转2进制 a、b交换数值 事件循环 Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/offer/base.html":{"url":"docs/offer/base.html","title":"基础内容","keywords":"","body":"js Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-25 22:26:19 "},"docs/gitBook/":{"url":"docs/gitBook/","title":"GitBook","keywords":"","body":"Gitbook常见命令 # 需要安装nodejs + yarn/npm node -v yarn -v/npm -v # 安装全局命令 yarn global add gitbook/npm install gitbook -g yarn global add gitbook-cli/npm install gitbook-cli -g # 查看是否安装成功 gitbook -V # 安装Gitbook依赖 gitbook install 此处依赖内容在package.json中的可以使用yarn/npm安装，安装速度更快 # 创建Gitbook项目 gitbook init 创建 # 本地启动预览 gitbook serve 本地启动 # 构建静态页面 gitbook build 打包 Gitbook上传github 在develop开发，build完成之后把_book目录拷贝到master分支，全部覆盖 Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 20:41:15 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"tags Copyright © 2019 haomingi all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 20:28:43 "}}